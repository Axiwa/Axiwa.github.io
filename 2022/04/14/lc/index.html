<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="Silent site" />
  

  
  
  
  
  
  
  <title>刷题 | Azure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正在从 https:&#x2F;&#x2F;github.com&#x2F;youngyangyang04&#x2F;leetcode-master 开始刷题！">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题">
<meta property="og:url" content="http://axiwa.github.io/2022/04/14/lc/index.html">
<meta property="og:site_name" content="Azure">
<meta property="og:description" content="正在从 https:&#x2F;&#x2F;github.com&#x2F;youngyangyang04&#x2F;leetcode-master 开始刷题！">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-13T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-07T10:43:30.034Z">
<meta property="article:author" content="Axiwa">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="https://axiwa.github.io" title="Azure" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Azure" rel="home">Azure</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        Silent site
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">MENU</button>
            <a class="assistive-text" href="/#content" title="JUMP TO">JUMP TO/a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-lc" class="post-lc post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      刷题
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://axiwa.github.io/2022/04/14/lc/" data-id="clxouwrvj000hx5cu7w2tbl8k" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>正在从 <a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master" class="uri">https://github.com/youngyangyang04/leetcode-master</a>
开始刷题！</p>
<span id="more"></span>
<h2 id="题">题</h2>
<h3 id="数组">数组</h3>
<p>长度为n的循环数组，从下标i开始倒着跳k格，新坐标咋算？</p>
<p>如果k可以被n整除，等于向前跳了<code>(k/n)*n-k</code>格，新坐标</p>
<p>如果k不能被n整除，等于向前跳了<code>ceil(k/n)*n-k</code>格，新坐标<code>(i+ceil(k/n)*n-k)%n</code></p>
<p>新坐标：<code>((i-k)%n+n)%n</code></p>
<p>往前跳k格也能用这个</p>
<h3 id="二分法">二分法</h3>
<p>Leetcode: 34, 35, 69, 367, 704 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [left, right]</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">  <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">if</span> (nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// [left, right)</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right){</span><br><span class="line">  <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">if</span> (nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
34题，第一个和最后一个位置，分别找第一个nums[left]&gt;=target和nums[right]&gt;target的索引，每一次满足要求，记录下该位置．两个值分别求
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = nums.size(); <span class="type">int</span> right = nums.size();  <span class="comment">// not nums.size()-1!!!</span></span><br><span class="line"><span class="keyword">while</span> (from&lt;=to){</span><br><span class="line">  <span class="type">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[mid]&gt;=target)</span><br><span class="line">    left = mid;</span><br><span class="line">    to = mid<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    from = mid+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">...</span><br></pre></td></tr></table></figure> 69/367 找平方根．牛顿法 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> t = <span class="number">1.0</span></span><br><span class="line">t = (t+x/x)/<span class="number">2</span></span><br></pre></td></tr></table></figure> 二分法，记得用long
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num&lt;<span class="number">2</span>) </span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="type">long</span> left = <span class="number">2</span>, right = num/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (left&lt;=right){</span><br><span class="line">  <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">if</span> (mid*mid &lt; num) left = mid+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (mid*mid &gt; num) right = mid<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> ...;</span><br><span class="line">  }</span><br></pre></td></tr></table></figure></p>
<h3 id="双指针">双指针</h3>
<p>Leetcode:</p>
<p>27.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">移除元素</a></p>
<p>左边的指针从0开始，右边的指针从nums.size()-1开始． <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right){</span><br><span class="line">  <span class="keyword">if</span> (nums[left] == target){</span><br><span class="line">    <span class="keyword">if</span> (nums[right] != target){</span><br><span class="line">      nums[left] = nums[right];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      right--;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    left++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>26.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">删除重复项</a></p>
<p>区别空数组和非空;
非空的<code>right</code>从１开始，<code>left</code>从０开始
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (right &lt; nums.size()){</span><br><span class="line">  <span class="keyword">if</span> (nums[right] != nums[left]){</span><br><span class="line">    left = left+<span class="number">1</span>;</span><br><span class="line">    nums[left] = nums[right];</span><br><span class="line">  }</span><br><span class="line">  right++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>80.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除重复项II</a></p>
<p>若可以保留k个重复项，区别数组长度&lt;=k和&gt;k;
<code>left</code>和<code>right</code>下标都从k开始.
如果<code>nums[left-k]!=nums[right]</code>，说明<code>nums[left]</code>应该被<code>nums[right]</code>替换，否则增加<code>right</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = k; <span class="type">int</span> right = k;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.size()){</span><br><span class="line">  <span class="keyword">if</span> (nums[right] != nums[left-k]){</span><br><span class="line">    nums[left] = nums[right];</span><br><span class="line">    left++;</span><br><span class="line">  }</span><br><span class="line">  right++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>844.<a target="_blank" rel="noopener" href="https://leetcode.com/problems/backspace-string-compare/">Backspace
String Compare</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water" class="uri">https://leetcode.com/problems/container-with-most-water</a></p>
<p>3Sum/3Sum2/4Sum...先排序，最后一层循环用双指针，只能降一个数量级 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum-ii/">4SumII</a>　用哈希表！少２个数量级！</p>
<p>142.<a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md">环形链表II</a></p>
<h3 id="滑动窗口">滑动窗口</h3>
<p>209.<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Minimum
Size Subarray Sum</a></p>
<p>76.<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></p>
<p>用map记录需要满足的字母和相应个数，用<code>satisfied</code>记录满足的字母总数，
<code>satisfied</code>满足时左指针右移至不再满足，记录满足的最小长度，<code>satisfied</code>不满足时右指针右移直到满足．一旦更改记录的<code>table</code>，检查相应元素的个数是否刚好满足/刚好不满足(<code>table[nums[left]] == 1 or table[nums[right]] == 0</code>)来改变对应的<code>satisfied</code></p>
<h3 id="旋转矩阵">旋转矩阵</h3>
<h3 id="快乐数">快乐数</h3>
<p>快乐数不是数学问题，是找循环的问题．<code>unordered_set</code> /
<code>快慢指针</code></p>
<h3 id="丑数和超级丑数">丑数和超级丑数</h3>
<p>最小堆/动态规划</p>
<h3 id="回溯">回溯</h3>
<p>对于二叉数，只能用前序遍历/后序遍历！</p>
<h4 id="组合去重">组合＆去重</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l; i&lt; r; i++){</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">//下标从传入的l开始</span></span><br><span class="line"><span class="comment">//找幂集: 选，或者不选，不需要for</span></span><br></pre></td></tr></table></figure>
<p>去重的方法 *
用<code>for</code>横向检查的时候，用unordered_set检查某一重复元素在本层是否被使用过，如果有,<code>continue</code>
*
<strong>排序</strong>之后，每一次用<code>for</code>横向检查的时候<code>if (i!=l &amp;&amp; nums[i] == nums[i-1]) continue;</code>
* <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列</a>不能排序，如果不用hash，需要保证有同样的元素时，只有一种顺序的可能．比如<code>[1,1,1]</code>，只可能有<code>[0,0,0][0,0,1],[0,1,1],[1,1,1]</code>，则
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[l] &gt;= mm){ <span class="comment">// if nums[l] &gt;= m 符合要求，可以选</span></span><br><span class="line">  path.push_back(nums[l]);</span><br><span class="line">  helper(nums, l+<span class="number">1</span>, nums[l])</span><br><span class="line">  path.pop_back();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (nums[l] != mm){　<span class="comment">// if nums[l] == m，说明之前选过和nums[l]相等的元素，则nums[l]不能再不选．否则，可以不选</span></span><br><span class="line">  helper(nums, l+<span class="number">1</span>, mm);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h4 id="排列去重">排列＆去重</h4>
<p>排列是选了<code>nums[i]</code>以后在剩下所有的<code>size-1</code>里面选．</p>
<ol type="1">
<li>对[1,2,3,4,5]，<code>l=0</code>时选1，从<code>l=1</code>开始挑([2,3,4,5])，选2，交换1和2，仍然从<code>l=2</code>开始挑[1,3,4,5]．．．
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l; i&lt;r; i++){</span><br><span class="line">  path.puch_back(nums[i]);</span><br><span class="line">  swap(nums[l], nums[i]);</span><br><span class="line">  helper(nums, l+<span class="number">1</span>, r);</span><br><span class="line">  swap(nums[l], nums[i]);</span><br><span class="line">  path.pop_back();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 用`used`数组表示某个元素在这一分支里是否已经选过，每次从<span class="number">0</span>开始挑，遇到`used[i] == <span class="literal">true</span>`跳过</span><br><span class="line"></span><br><span class="line">第一种方法无法去重，因为我们需要有序的集合．</span><br><span class="line">```c</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;r; i++){</span><br><span class="line">  <span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="comment">// used[i-1]==false说明这一层已经用过第一个出现的该元素了，跳过</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">if</span> (!used[i]){</span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    path.push_back(nums[i]);</span><br><span class="line">    helper(nums, l+<span class="number">1</span>, r, used);</span><br><span class="line">    path.pop_back();</span><br><span class="line">    used[i] =<span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">用<span class="built_in">set</span>也可以，但是要先将数组排序</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二叉搜索树">二叉搜索树</h3>
<p>Morris遍历</p>
<h3 id="图">图</h3>
<h4 id="dfsbfs">DFS&amp;BFS</h4>
<h3 id="位运算">位运算</h3>
<p>按位或： |</p>
<p>按位与： &amp;</p>
<p>判断某数的某一位i为1/0：<code>(a&gt;&gt;i)&amp;1</code>. NOTE:
位运算的优先级最低（先算术运算，后移位运算，最后位运算），记得加括号！！</p>
<h4 id="状态压缩">状态压缩</h4>
<p>用一个n位的k进制数，代表n个元素的k个状态 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/">好子集的个数</a>
状态压缩+动态规划</p>
<h2 id="c">C++</h2>
<ul>
<li><p>__gcd
()函数是内置于algorithm头文件中的函数，主要是用于求两个数的最大公约数</p></li>
<li><p>创建二维数组 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; matrix(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// matrix.size() = n</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>map <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">m[<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">m[<span class="string">'a'</span>]++;</span><br><span class="line"><span class="comment">//可以直接用</span></span><br><span class="line"><span class="comment">//不希望存在的key，不要用m[key]，用m.find(key) == m.end()．否则会被创建出来！</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>定义链表 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>{</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  ListNode *next;</span><br><span class="line">  ListNode() : val(<span class="number">0</span>), next(nullptr) {}</span><br><span class="line">  ListNode(<span class="type">int</span> x): val(x), next(nullptr) {}</span><br><span class="line">  ListNode(<span class="type">int</span> x, ListNode *next): val(x), next(next) {}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>定义二叉树 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>{</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode * left;</span><br><span class="line">    TreeNode * right;</span><br><span class="line">    TreeNode(<span class="type">int</span> x): val(x), left(nullptr), right(nullptr) {};</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>Hash &amp; map <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>　<span class="comment">//AVL实现</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multiset</span></span><br><span class="line"><span class="comment">//红黑树，有序.查询和增减效率O(logn)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_set</span> <span class="comment">//哈希表．查询和增减效率O(1)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>　<span class="comment">//AVL实现</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">multimap</span>　<span class="comment">//key可重复</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>　<span class="comment">//哈希表实现．key无序　O(1)</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"12345"</span>;</span><br><span class="line">sort(a.begin(), a.end());</span><br><span class="line"><span class="built_in">string</span> a[n];</span><br><span class="line">sort(a,a+n);</span><br></pre></td></tr></table></figure></p></li>
<li><p>INT_MAX / INT_MIN <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="comment">// INT_MAX =  2^31-1</span></span><br><span class="line"><span class="comment">// INT_MIN = -2^31</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Iterator是个啥 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正向</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt; mm;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter = mm.begin(); iter!= mm.end(); iter++){</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">" "</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//反向</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt; mm;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="type">int</span>&gt;::reverse_iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter = mm.rbegin(); iter != mm.rend(); iter++){</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>不知道的函数．．． <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique</span><br><span class="line">reverse <span class="comment">//reverse(rev.begin(), rev.end());</span></span><br><span class="line">sort</span><br><span class="line">resize <span class="comment">// s.resize(newSize);</span></span><br><span class="line">replace <span class="comment">//</span></span><br><span class="line">emplace</span><br><span class="line">substr <span class="comment">// s.substr(starting pos: int, length): string</span></span><br><span class="line"><span class="comment">//原来swap函数是自带的！</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>位操作 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>{</span><br><span class="line">    <span class="keyword">if</span> (a != b){</span><br><span class="line">        a ^= b;</span><br><span class="line">        b ^= a;</span><br><span class="line">        a ^= b;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>引用和指针</p></li>
<li><p>容器和容器适配器，底层的实现，性能</p></li>
</ul>
<p>容器适配器的底层使用不同的容器，使得容器适配器内的数据在内存中不连续．默认的底层容器是deque.</p>
<h2 id="n-queens">N-Queens</h2>
<p><em>For a chessboard of any size, there can't be two queens in the
same row, column, or diagonal.</em></p>
<p>We can solve this problem with a recursive algorithm. Suppose each
queen is placed in each row, i.e. n queens takes row 1 to row n, and we
should determine their columns.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span></span>(n: <span class="type">Int</span>)= </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeQueens</span></span>(k: <span class="type">Int</span>): <span class="type">Set</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="comment">// with k queens, the set of solutions</span></span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">0</span> <span class="keyword">then</span> <span class="type">Set</span>(<span class="type">List</span>())</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">for</span> </span><br><span class="line">                queens &lt;- placeQueens(k<span class="number">-1</span>) <span class="comment">// with k-1 queens, the set of solutions</span></span><br><span class="line">                col &lt;- <span class="number">0</span> until n <span class="comment">// the column of the k th queen</span></span><br><span class="line">                <span class="keyword">if</span> isSafe(col, queens) <span class="comment">// safe means a solution</span></span><br><span class="line">            <span class="keyword">yield</span> col::queens</span><br><span class="line">    placeQueens(n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSafe</span></span>(col: <span class="type">Int</span>, queens: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = </span><br><span class="line">        !checks(col, <span class="number">1</span>, queens)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checks</span></span>(col: <span class="type">Int</span>, delta: <span class="type">Int</span>, queens: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = queens <span class="keyword">match</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="literal">false</span> <span class="comment">// no other queens, no check</span></span><br><span class="line">        <span class="keyword">case</span> qcol::others =&gt;</span><br><span class="line">            qcol == col                     <span class="comment">// same column</span></span><br><span class="line">            || (qcol-col).abs == delta      <span class="comment">// diagonal check</span></span><br><span class="line">            || checks(col, delta+<span class="number">1</span>, others) <span class="comment">// check next queen</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/godenlove007/article/details/7721647">fprintf
vs. fwrite</a></li>
</ul>
<h2 id="kmp">KMP</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7041827#t10">从头到尾彻底理解KMP</a></p>
<h2 id="water-pouring-puzzle">Water pouring puzzle</h2>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2022/04/14/lc/">
    <time datetime="2022-04-13T16:00:00.000Z" class="entry-date">
        2022-04-14
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
  </div>

    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2022/04/14/Monads/" rel="prev"><span class="meta-nav">←</span> Monad</a></span>
    
    
        <span class="nav-next"><a href="/2021/11/02/How-to-create-a-blog/" rel="next">How to create a blog by hexo&amp;github <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-graphics/">Computer graphics</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Debug/">Debug</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Knowledge/">Knowledge</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lecture-notes/">Lecture notes</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Project/">Project</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BA%9F%E8%AF%9D/">废话</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9/">玩</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%91%E5%9B%A2/">跑团</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2024/03/15/Reading/">读书</a>
          </li>
        
          <li>
            <a href="/2024/03/07/diary/">日记</a>
          </li>
        
          <li>
            <a href="/2024/01/27/story/">故事</a>
          </li>
        
          <li>
            <a href="/2023/06/17/coc/">跑团Replay观看记录</a>
          </li>
        
          <li>
            <a href="/2023/04/02/VulkanBasic/">Vulkan学习(1) Basics</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2024 Axiwa
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>