<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  <meta name="referrer" content="unsafe-url">
  
  <title>Scala notes</title>
  <meta name="author" content="Axiwa">
  <meta name="description" content="Silent site">
  
  
  <meta property="og:title" content="Scala notes"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="Azure"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="Azure" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        Scala notes
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2022-12-12T21:55:01.385Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2022-12-12
</time>


    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/Lecture-notes/">Lecture notes</a>





    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#elements"><span class="toc-text">Elements</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#evaluation-strategy"><span class="toc-text">Evaluation strategy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#termination-of-evaluation-strategy"><span class="toc-text">Termination of evaluation
strategy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blocks-and-lexical-scope"><span class="toc-text">Blocks and Lexical Scope</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tail-recursion"><span class="toc-text">Tail recursion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#higher-order-functions"><span class="toc-text">Higher-order functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-abstraction"><span class="toc-text">Data abstraction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class"><span class="toc-text">Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objects"><span class="toc-text">Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trait"><span class="toc-text">Trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#methods"><span class="toc-text">Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-reference"><span class="toc-text">Self reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enums-lec-1.4.4"><span class="toc-text">Enums [Lec 1.4.4]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#option-type"><span class="toc-text">Option Type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#deal-with-types-lec-1.4.1-lec-1.4.5-1.4.6"><span class="toc-text">Deal with types [Lec
1.4.1] [Lec 1.4.5, 1.4.6]</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#type-tests"><span class="toc-text">Type tests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pattern-matching"><span class="toc-text">Pattern Matching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-bounds"><span class="toc-text">Type bounds</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#variance-lec-1.4.6"><span class="toc-text">Variance [Lec 1.4.6]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-parameters"><span class="toc-text">Type parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#generic-functions"><span class="toc-text">Generic Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implicit-parameter"><span class="toc-text">Implicit parameter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#collections"><span class="toc-text">Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lists"><span class="toc-text">Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reduction-of-lists-lec-1-5-4"><span class="toc-text">Reduction of Lists (Lec
1-5-4)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple-class"><span class="toc-text">Tuple class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vectors"><span class="toc-text">Vectors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ranges"><span class="toc-text">Ranges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sets"><span class="toc-text">Sets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maps"><span class="toc-text">Maps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lazylist"><span class="toc-text">LazyList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#functions-for-collections"><span class="toc-text">Functions for collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mapping"><span class="toc-text">Mapping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filtering"><span class="toc-text">Filtering</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-expressions"><span class="toc-text">For-Expressions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#syntactic-miscellaneous"><span class="toc-text">Syntactic Miscellaneous</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#makestring"><span class="toc-text">makeString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#override-def"><span class="toc-text">override def</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#conditions"><span class="toc-text">Conditions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#infix-notation"><span class="toc-text">Infix Notation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exceptions"><span class="toc-text">Exceptions</span></a></li></ol></li></ol>
    
    <div class="picture-container">
      
    </div>
    <h1 id="elements">Elements</h1>
<h2 id="evaluation-strategy">Evaluation strategy</h2>
<p><strong>Call-by-value</strong>:</p>
<p>A strict evaluation strategy, in which the expression is evaluated
and bound to the corresponding parameter before the function body is
evaluated.</p>
<p>The <code>val</code> form is CBV. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> z =&#123;</span><br><span class="line">    println(<span class="string">&quot;z&quot;</span>);</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Running this will
give <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z</span><br><span class="line"><span class="keyword">val</span> z: <span class="type">Int</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure> Calling <code>z</code> will not print "z" because it
has been evaluated while defined.</p>
<p>Scala uses CBV by default.</p>
<p><strong>Call-by-name</strong>:</p>
<p>A non-strict evaluation strategy which will defer the evaluation of
the expression until the program needs it.</p>
<p>The <code>def</code> form is CBN. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">z</span> </span>=&#123;</span><br><span class="line">    println(<span class="string">&quot;z&quot;</span>);</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Running this will
only give <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">z</span></span>: <span class="type">Int</span></span><br></pre></td></tr></table></figure> But every time calling <code>z</code> will print
"z".</p>
<p>Definitions of functions can have parameters. To make a parameter CBN
just add <code>=&gt;</code> before the type. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constOne</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) =<span class="number">1</span></span><br></pre></td></tr></table></figure>
<code>x</code> is CBV, and <code>y</code> is CBN.</p>
<p><strong>Lazy evaluation</strong> Avoid computing the elements of a
sequence until they are needed for the evaluation result. See <a
href="#lazylist">LazyList</a>.</p>
<p>To solve the problem of recomputing many times, we can store the
result of the first evaluation of a value and reuse the stored result
instead of recomputing.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> y = &#123; print (<span class="string">&quot;y&quot;</span>); <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="termination-of-evaluation-strategy">Termination of evaluation
strategy</h3>
<p>If CBV evaluation of an expression eterminates, then CBN evaluation
terminates, too.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) =x</span><br><span class="line">first(<span class="number">1</span>,loop)</span><br></pre></td></tr></table></figure>
<p>Under CBN it will give 1, while under CBV it will loop.</p>
<h2 id="blocks-and-lexical-scope">Blocks and Lexical Scope</h2>
<p><strong>Blocks</strong>: {} The last element of a block is an
expression that defines its value. The definitions inside a block are
only visible from within the block, and will shadow definitions of the
same names outside the block (Definitions of outer blocks are visible
inside a block unless they are shadowed).</p>
<p>In Scala 3, braces are optional around a <strong>correctly</strong>
intented expression that appears after
<code>=, then, else, ...</code></p>
<h2 id="tail-recursion">Tail recursion</h2>
<p>One can equire that a function is tail-recursive using a <span
class="citation" data-cites="tailrec">@tailrec</span> annotation:
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.annotation.tailrec</span><br><span class="line"></span><br><span class="line"><span class="meta">@tailrec</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(...):<span class="type">Int</span> = ...</span><br></pre></td></tr></table></figure></p>
<h2 id="higher-order-functions">Higher-order functions</h2>
<p>Type <code>A =&gt; B</code> is the type of a function that takes an
argument of type A and returns a result of type B. Anonymous Functions
can be expressed as follows: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x1: <span class="type">T1</span>,...,xn: <span class="type">Tn</span>) =&gt; <span class="type">E</span></span><br></pre></td></tr></table></figure> which means <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x1: <span class="type">T1</span>,...,xn: <span class="type">Tn</span>) = <span class="type">E</span>;</span><br><span class="line">f</span><br></pre></td></tr></table></figure> E
is the body and x_n is the parameters of the function.</p>
<p>The definintion of funtions that return funtions is useful.
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(ps_1)...(ps_n) = <span class="type">E</span></span><br></pre></td></tr></table></figure> where n&gt;1, is equivalent to</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(ps_1)...(ps_n_1) = &#123;<span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(ps_n) = <span class="type">E</span>; g&#125;</span><br></pre></td></tr></table></figure>
<p>So the left side needs to take <code>ps_n</code> and return E of all
the parameters.</p>
<p>By repeating the process, the expression is shown to be equivalent to
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= (ps_1 =&gt; (ps_2 =&gt; (...(ps_n =&gt; <span class="type">E</span>))))</span><br></pre></td></tr></table></figure></p>
<p>Note that function types <strong>associate to the right</strong>,
whiuich means <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> =&gt; <span class="type">Int</span> =&gt; <span class="type">Int</span></span><br><span class="line">is equivalent to </span><br><span class="line"><span class="type">Int</span> =&gt; (<span class="type">Int</span> =&gt; <span class="type">Int</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="data-abstraction">Data abstraction</h2>
<h3 id="class">Class</h3>
<p><strong>Abstract Classes</strong> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSet</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span> <span class="comment">//insert an elem</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span></span><br></pre></td></tr></table></figure> Abstract classes can
(but not necessarily) contain members which are missing an
implementation.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">IntSet</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span> = <span class="type">NonEmpty</span>(x, <span class="type">Empty</span>(), <span class="type">Empty</span>())</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonEmpty</span>(<span class="params">elem: <span class="type">Int</span>, left: <span class="type">IntSet</span>, right: <span class="type">IntSet</span></span>) <span class="keyword">extends</span> <span class="title">IntSet</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = ...</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span> = ...</span><br></pre></td></tr></table></figure>
<p><code>Empty</code> and <code>NonEmpty</code> extend the class
<code>IntSet</code>, and they are <em>subclass</em> of
<code>IntSet</code>. <code>IntSet</code> is the <em>superclass</em> of
<code>Empty</code> and <code>NonEmpty</code>.</p>
<p>It is possible to redefine an existing, non-abstract definition in a
subclass by using <code>override def</code>.</p>
<h3 id="objects">Objects</h3>
<p>Create an object by calling the constructor of the class.</p>
<p><code>Object definition</code> defines a singleton object of an
abstract class.Once it is defined, no other instance of it can be
created. Singleton object evaluates to itself. Objects live in the term
namespace, whereas classes live inthe type namespace. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">IntSet</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">incl</span></span>(x: <span class="type">Int</span>): <span class="type">IntSet</span> = <span class="type">NonEmpty</span>(x, <span class="type">Empty</span>, <span class="type">Empty</span>) </span><br></pre></td></tr></table></figure></p>
<p>If a class and object with the same name are given in the same
sourcefile, we call them <code>companions</code>. A companion object of
a class plays a role similar to static class definitions. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> ...</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntSet</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">singleton</span></span>(x: <span class="type">Int</span>) = <span class="type">NonEmpty</span>(x, <span class="type">Empty</span>, <span class="type">Empty</span>)</span><br></pre></td></tr></table></figure>
It is possible to create standalone applications in Scala using an
object with a main method. Or just add a <code>@main</code> before the
function definition.</p>
<p>To place a class or object inside a package, use a package cluase at
the top of the source file. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"></span><br><span class="line">&gt; scala example.<span class="type">Hello</span></span><br><span class="line">&gt; <span class="keyword">import</span> example.<span class="type">Rational</span></span><br><span class="line">&gt; <span class="keyword">import</span> example._</span><br></pre></td></tr></table></figure> #### Objects everywhere [Lec
1.3.4] Boolean type can be implemented like normal classes.
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">extends</span> <span class="title">AnyVal</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ifThenElse</span></span>[<span class="type">T</span>](t: =&gt; <span class="type">T</span>, e: =&gt;<span class="type">T</span>): <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">&amp;&amp;</span> </span>(x: =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = ifThenElse(x, <span class="literal">false</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">||</span> </span>(x: =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span> = ifThenElse(<span class="literal">true</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">true</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ifThenELese</span></span>[<span class="type">T</span>](t: =&gt; <span class="type">T</span>,e: =&gt; <span class="type">T</span>) = t</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">false</span> <span class="keyword">extends</span> <span class="title">Boolean</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ifThenELese</span></span>[<span class="type">T</span>](t: =&gt; <span class="type">T</span>,e: =&gt; <span class="type">T</span>) = e</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> (x: <span class="type">Boolean</span>):</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">===&gt;</span> </span>(y: <span class="type">Boolean</span>) = x.ifThenElse(y, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure> Natural numbers can be implemented like normal classes.
Function values are treated as objects in Scala, and functions are
objects with <code>apply</code> methods. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function</span>[<span class="type">A</span>,<span class="type">B</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">B</span></span><br><span class="line"></span><br><span class="line">(x: <span class="type">Int</span>) =&gt; x*x</span><br><span class="line"><span class="comment">//means</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">Function</span>[<span class="type">Int</span>, <span class="type">Int</span>]:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x*x</span><br></pre></td></tr></table></figure> A function call
f(a,b) is expanded to f.apply(a,b)</p>
<h3 id="trait">Trait</h3>
<p>A class has several natural supertypes to which it conforms or from
which it wants to inherit code. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Planar</span></span>: </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">height</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">width</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">surface</span> </span>= height * width</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Planar</span> </span></span><br></pre></td></tr></table></figure> Classes, object and
traits can inherit from at most one class but arbitrary many traits.</p>
<h3 id="methods">Methods</h3>
<p>Package functions operating on a data abstraction in the data
abstraction itself. Such functions inside the class are called methods.
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>)</span>:</span><br><span class="line">	require(y!=<span class="number">0</span>, <span class="string">&quot;denominator must be non-zero&quot;</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = </span><br><span class="line">		<span class="keyword">if</span> b==<span class="number">0</span> <span class="keyword">then</span> a <span class="keyword">else</span> gcd(b, a%b)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">val</span> g = gcd(x.abs, y.abs)</span><br><span class="line">	<span class="keyword">val</span> numer = x/g</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">denom</span> </span>= y/g</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(r: <span class="type">Rational</span>) = </span><br><span class="line">		<span class="type">Rational</span>(numer * r.denom + r.numer * denom, denom * r.denom)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">neg</span> </span>= <span class="type">Rational</span>(-numer, denom)</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s&quot;<span class="subst">$numer</span>/<span class="subst">$denom</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="type">Rational</span> <span class="comment">// `end` must align with the opening keyword, followed by the name in the definition.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Rational</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> y = <span class="type">Rational</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">x.g <span class="comment">//Error: value g in class Rational cannot be accessed as a member of x</span></span><br><span class="line">x.add(y) <span class="comment">//x+y</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure> <code>private</code> means it cannot be called outside
the class.</p>
<h3 id="self-reference">Self reference</h3>
<p>On the inside of a class, the name <code>this</code> represents the
object on which the current method is executed. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>)</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">less</span></span>(that: <span class="type">Rational</span>): <span class="type">Boolean</span> = </span><br><span class="line">		<span class="keyword">this</span>.numer * that.denom &lt; that.numer * <span class="keyword">this</span>.denom <span class="comment">//`this` can be omitted</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(that: <span class="type">Rational</span>): <span class="type">Rational</span> = </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">this</span>.less(that) <span class="keyword">then</span> that <span class="keyword">else</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure> ####
Auxiliary Constructors <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">x: <span class="type">Int</span>, y: <span class="type">Int</span></span>)</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(x: <span class="type">Int</span>) = <span class="keyword">this</span>(x, <span class="number">1</span>) <span class="comment">//auxiliary method</span></span><br><span class="line"><span class="type">Rational</span>(<span class="number">2</span>) <span class="comment">// 2/1</span></span><br></pre></td></tr></table></figure> ### Extension Methods Not having
to define all methods that belong to a class inside the class itself.
Extensions can only add new members, and cannot refer to ohter class
members via <code>this</code>. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension(r: <span class="type">Rational</span>):</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(s: <span class="type">Rational</span>): <span class="type">Boolean</span> = <span class="keyword">if</span> s.less(r) <span class="keyword">then</span> s <span class="keyword">else</span> r</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>: <span class="type">Rational</span> = <span class="type">Rational</span>(r.numer.abs, r.denom)</span><br></pre></td></tr></table></figure> Extensions can define
operators. For example, operators such as <code>+</code> or
<code>&lt;</code> count as identifiers in Scala. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension(x: <span class="type">Rational</span>):</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">+</span> </span>(y: <span class="type">Rational</span>): <span class="type">Rational</span> = x.add(y)</span><br></pre></td></tr></table></figure></p>
<h3 id="enums-lec-1.4.4">Enums [Lec 1.4.4]</h3>
<p>An enum enumerates all the cases of an ADT(algebraic data types) and
nothing else.</p>
<p>What is <em>algebraic data types</em>? Pure data definitions like
this <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Var</span>(<span class="params">s: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br></pre></td></tr></table></figure> We need to use <code>Expr.Number(1)</code> instead
of <code>Number(1)</code>, or use <code>import Expr._</code></p>
<p>We can define the above like this: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Expr</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Var</span>(s: <span class="type">String</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n: <span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Prod</span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>)</span><br></pre></td></tr></table></figure> Enums can take
parameters and can define methods. Enum cases that pass parameters have
to use an explicit <code>extends</code> clause.</p>
<p>An enum can comprise parameterized and simple cases at the same
time.</p>
<h3 id="option-type">Option Type</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Option</span>[+<span class="type">A</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>[+<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>]</span></span><br></pre></td></tr></table></figure>
<p>Options can be decomposed using pattern matching.</p>
<h1 id="deal-with-types-lec-1.4.1-lec-1.4.5-1.4.6">Deal with types [Lec
1.4.1] [Lec 1.4.5, 1.4.6]</h1>
<h2 id="type-tests">Type tests</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.isInstanceOf[<span class="type">T</span>] <span class="comment">//Boolean</span></span><br><span class="line">x.asInstanceOf[<span class="type">T</span>].method <span class="comment">//T.method</span></span><br></pre></td></tr></table></figure>
<p>Ugly and unsafe.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p><strong>case class</strong> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = e <span class="keyword">match</span> <span class="comment">// def eval: Int = this match ...</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</span><br></pre></td></tr></table></figure> <code>MatchError</code> is
thrown if no pattern matches the value of the selector.</p>
<h2 id="type-bounds">Type bounds</h2>
<p><code>S &lt;: T</code> means S is a subtype of T.
<code>S &gt;: T</code> means S is a supertype of T.
<code>S &gt;: NonEmpty &lt;: IntSet</code> restricts S any type on the
interval between NonEmpty and IntSet.</p>
<h3 id="variance-lec-1.4.6">Variance [Lec 1.4.6]</h3>
<p>C<a href="type%20parameters">T</a> is a parameterized type and A, B
are types such that A &lt;: B. <strong>If A &lt;: B, the everything one
can do with a value of type B one should also be able to do with a value
of type A.</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">C</span>[<span class="type">A</span>] &lt;: <span class="type">C</span>[<span class="type">B</span>] <span class="comment">// C is covariant. class C[+A]</span></span><br><span class="line"><span class="type">C</span>[<span class="type">A</span>] &gt;: <span class="type">C</span>[<span class="type">B</span>] <span class="comment">// C is contravariant. class C[-A]</span></span><br><span class="line">neither <span class="type">C</span>[<span class="type">A</span>] and <span class="type">C</span>[<span class="type">B</span>] is a subtype of the other <span class="comment">// C is nonvariant. class C[A]</span></span><br></pre></td></tr></table></figure>
<p>If A2 &lt;: A1 and B1 &lt;: B2 then A1 =&gt; B1 &lt;: A2 =&gt; B2</p>
<p><code>A &lt;: B</code> =&gt; <code>List[A] &lt;: List[B]</code>. List
is covariant. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>]</span></span><br></pre></td></tr></table></figure> Array in Scala is not covariant.</p>
<p>Covariant type parameters can only appear in method results.
Contravariant type parameters can only apperat in method parameters. In
variant type parameters can appear anywhere.</p>
<p>Convariant type parameters may appear in lower bounds of method type
parameters. Contravariant type parameters may appear in upper
bounds.</p>
<h2 id="type-parameters">Type parameters</h2>
<h3 id="generic-functions">Generic Functions</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span></span>[<span class="type">T</span>](elem: <span class="type">T</span>) = <span class="type">Cons</span>[<span class="type">T</span>](elem, <span class="type">Nil</span>[<span class="type">T</span>])</span><br><span class="line"></span><br><span class="line">singleton[<span class="type">Int</span>](<span class="number">1</span>)</span><br><span class="line">singleton[<span class="type">Boolean</span>](<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h3 id="implicit-parameter">Implicit parameter</h3>
<p>The compiler infers the argument value based on its expected
type.</p>
<p>An implicit parameter is introduced by a using parameter clause like
this: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])(<span class="keyword">using</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicit argument:</span></span><br><span class="line">sort(string)(<span class="keyword">using</span> <span class="type">Ordering</span>.<span class="type">String</span>) <span class="comment">// the argument can be left out</span></span><br></pre></td></tr></table></figure> Multiple parameters can be in a using clause or
several using clauses. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>)(<span class="keyword">using</span> a: <span class="type">A</span>, b: <span class="type">B</span>) = ...</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>)(<span class="keyword">using</span> a: <span class="type">A</span>)(<span class="keyword">using</span> b: <span class="type">B</span>) = ...</span><br><span class="line"></span><br><span class="line">f(x)(<span class="keyword">using</span> a, b)</span><br></pre></td></tr></table></figure> Parameters of a using clause can
be anonymous, or using a context bound <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])(<span class="keyword">using</span> <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>[<span class="type">T</span>: <span class="type">Ordeing</span>](xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>]  = ...</span><br></pre></td></tr></table></figure> #### Given
Instances <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Ordering</span></span>:</span><br><span class="line">	<span class="keyword">given</span> <span class="type">Int</span> as <span class="type">Ordering</span>[<span class="type">Int</span>]: <span class="comment">// what is after as is the true name of this instance  </span></span><br><span class="line">	<span class="comment">// This code defines a given instance of type Ordering[Int], named Int (or other names!).</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> ...</span></span><br><span class="line">	<span class="keyword">given</span> <span class="type">Ordering</span>[<span class="type">Double</span>]: <span class="comment">//given abitrary name as Ordering[Double]</span></span><br><span class="line">	<span class="comment">//Anonymous given instance</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> ...</span></span><br></pre></td></tr></table></figure> A type class trait may define extension
methods, to contain comparison methods like this: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordering</span>[<span class="type">A</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">A</span>, y: <span class="type">A</span>): <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">extension</span> (x: <span class="type">A</span>)</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">&lt;</span> </span>(y: <span class="type">A</span>): <span class="type">Boolean</span> = compare(x, y) &lt; <span class="number">0</span></span><br><span class="line">		...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Extension methods on a type class trait are visible whenever a given
instance for the trait is available. #### Summoning an Instance Refering
to an instance by its type. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">summon[<span class="type">Ordering</span>[<span class="type">Int</span>]]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">summon</span></span>[<span class="type">T</span>](<span class="keyword">using</span> x: <span class="type">T</span>) = x</span><br></pre></td></tr></table></figure></p>
<h1 id="collections">Collections</h1>
<h2 id="lists">Lists</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">T</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[<span class="type">T</span>](<span class="params">val head: <span class="type">T</span>, val tail: <span class="type">List</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nil</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">true</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">&quot;Nil.head&quot;</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>= <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span>(<span class="string">&quot;Nil.tail&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Lists are homogeneous. The type of a list with elements of type T is
written as List<a href="type%20parameters">T</a>/scala.List<a
href="type%20parameters">T</a>.</p>
<p>All lists are constucted from: empty list <code>Nil</code> and
construction operation <code>::</code>. For example: <code>x::xs</code>
give a new list with the first element x followed by elements of xs.
<strong>Operators ending in ":" associate to the right</strong>.</p>
<p>Operations on Lists: <a
target="_blank" rel="noopener" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html">List</a></p>
<p>Often used: (also for other sequences) <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">:+ <span class="comment">// append an element at the end</span></span><br><span class="line">::</span><br><span class="line">::: or ++ <span class="comment">//concatenation</span></span><br><span class="line">contains</span><br><span class="line">head </span><br><span class="line">last</span><br><span class="line">tail</span><br><span class="line">init</span><br><span class="line">isEmpty/nonEmpty</span><br><span class="line">exists(p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">val a = &quot;some random test message&quot;</span></span><br><span class="line"><span class="comment">val keys = List(&quot;hi&quot;,&quot;random&quot;,&quot;test&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">To check whether the string `a` contains any values from `keys`:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">keys.exists(a.contains)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">filter</span><br><span class="line">filterNot</span><br><span class="line">withFilter <span class="comment">// used in map, flatMap, foreach. It will not produce a new collection.</span></span><br><span class="line">find <span class="comment">// return an Option, use `get` to get the value</span></span><br><span class="line">indexOf</span><br><span class="line">map</span><br><span class="line">forall(p)</span><br><span class="line">flatMap(f)</span><br><span class="line">flatten</span><br><span class="line">foldLeft</span><br><span class="line">foldRight</span><br><span class="line">length</span><br><span class="line">sort</span><br><span class="line">mkString</span><br><span class="line">reverse</span><br><span class="line">take(n)</span><br><span class="line">drop(n)</span><br><span class="line">sorted <span class="comment">// default acsending order for the type</span></span><br><span class="line">sortWith(order) <span class="comment">// e.g. _.length &lt; _.length</span></span><br><span class="line">xs.zip(ys) <span class="comment">// A sequence of pairs drawn from corresponding elements of sequences xs and ys</span></span><br><span class="line">span(p: (<span class="type">A</span>) =&gt; <span class="type">Boolean</span>) <span class="comment">// Splits this list into a prefix/suffix pair according to a predicate.</span></span><br><span class="line">distinct <span class="comment">//make elements distinct</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reduction-of-lists-lec-1-5-4">Reduction of Lists (Lec
1-5-4)</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(x1,...,xn).reduceLeft(op) = x1.op(x2).op(x3)... .op(xn)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="number">0</span>::xs).reduceLeft((x,y) =&gt; x+y) <span class="comment">// (_+_)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], z: <span class="type">B</span>)(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = </span><br><span class="line">	as <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</span><br><span class="line">		<span class="keyword">case</span> x::xs =&gt; f(x, foldRight(xs, z)(f))</span><br><span class="line">	&#125;</span><br><span class="line"><span class="type">List</span>(x1,...,xn).foldRight(z)(f) = x1.op(x2.op(...xn.op(z)))</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], z: <span class="type">B</span>)(f: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = </span><br><span class="line">	as <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</span><br><span class="line">		<span class="keyword">case</span> x::xs =&gt; foldLeft(xs, f(z, x))(f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>foldRight</code> and <code>foldLeft</code> can also be methods
of an abstract class: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foldLeft(as, z)(f) = z.op(x1).op(x2). ... .op(xn)</span><br></pre></td></tr></table></figure> ### Reasoning about Lists:
Referential Transparency To prove a property P(xs) for all lists xs. *
show that P(Nil) holds * For a list xs and some element x, show if P(xs)
holds, then P(x::xs) holds</p>
<h2 id="tuple-class">Tuple class</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair = (<span class="string">&quot;answer&quot;</span>, <span class="number">42</span>)</span><br><span class="line">pair._1 <span class="comment">// String = answer</span></span><br><span class="line">pair._2 <span class="comment">// Int = 42</span></span><br></pre></td></tr></table></figure>
<h2 id="vectors">Vectors</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x +: xs </span><br><span class="line">xs :+ x </span><br><span class="line"><span class="comment">// x is element, xs is the  =sequence</span></span><br></pre></td></tr></table></figure>
<h2 id="ranges">Ranges</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r: <span class="type">Range</span> = <span class="number">1</span> until <span class="number">5</span> <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line"><span class="keyword">val</span> s: <span class="type">Range</span> = <span class="number">1</span> to <span class="number">5</span> <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="keyword">val</span> t: <span class="type">Range</span> = <span class="number">1</span> to <span class="number">10</span> by <span class="number">3</span> <span class="comment">// 1, 4, 7, 10</span></span><br><span class="line">r.toList <span class="comment">// List(1, 2, 3, 4)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="sets">Sets</h2>
<p>Sets are unordered and do not have duplicate elements.
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fruit = <span class="type">Set</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> s = (<span class="number">1</span> to <span class="number">6</span>).toSet</span><br><span class="line">fruit.contains(<span class="string">&quot;apple&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="maps">Maps</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map[Key, Value]</span></span><br><span class="line"><span class="keyword">val</span> hey = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;B&quot;</span> -&gt; <span class="number">2</span>, <span class="string">&quot;C&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> hi = <span class="type">Map</span>(<span class="string">&quot;B&quot;</span> -&gt; <span class="number">4</span>)</span><br><span class="line">hey(<span class="string">&quot;A&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">hey.get(<span class="string">&quot;A&quot;</span>) <span class="comment">// Some(1)</span></span><br></pre></td></tr></table></figure>
<p>Some operations: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Concatenation</span></span><br><span class="line">hey ++ hi <span class="comment">// Map(A -&gt; 1, B -&gt; 4, C -&gt; 3)</span></span><br><span class="line">hi ++ hey <span class="comment">// Map(B -&gt; 2, A -&gt; 1, C -&gt; 3)</span></span><br><span class="line"><span class="comment">// Maybe what is after ++ will update the value</span></span><br><span class="line"></span><br><span class="line">hey + (<span class="string">&quot;D&quot;</span> -&gt; <span class="number">5</span>) <span class="comment">// Map(A -&gt; 1, B -&gt; 2, C -&gt; 3, D -&gt; 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupBy:</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="type">List</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;peach&quot;</span>)</span><br><span class="line">a.groupBy(_.head) <span class="comment">// HashMap(a -&gt; List(apple), b -&gt; List(banana), p -&gt; List(pear, peach))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default Values: turn a map into a function</span></span><br><span class="line"><span class="keyword">val</span> temp = hey.withDefaultValue(<span class="number">42</span>)</span><br><span class="line">temp(<span class="string">&quot;A&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">temp(<span class="string">&quot;K&quot;</span>) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure> We can use map to map a String to a
sequence <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="type">Map</span>(&#x27;<span class="type">A</span>&#x27; -&gt; <span class="number">1</span>, &#x27;<span class="type">B</span>&#x27; -&gt; <span class="number">2</span>, &#x27;<span class="type">C</span>&#x27; -&gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a.toUpperCase.map(b) <span class="comment">// ArraySeq(1, 2, 3)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="lazylist">LazyList</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> xs = <span class="type">LazyList</span>.cons(<span class="number">1</span>, <span class="type">LazyList</span>.cons(<span class="number">2</span>, <span class="type">LazyList</span>.empty))</span><br><span class="line"><span class="keyword">val</span> a = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">a.to(<span class="type">LazyList</span>) <span class="comment">// toLazyList</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LazyListsupport almost all methods of List. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x #:: xs = <span class="type">LazyList</span>.cons(x, xs)</span><br><span class="line"><span class="comment">// note the #, ite produces a lazy list</span></span><br></pre></td></tr></table></figure></p>
<p>LazyList can define infinite lists. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] = n #:: from(n+<span class="number">1</span>) </span><br><span class="line"><span class="keyword">val</span> nat = from(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// This is a kind of method to generate infinite list.</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>) = (guess + x/guess)/<span class="number">2</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> guesses: <span class="type">LazyList</span>[<span class="type">Double</span>] = <span class="number">1</span> #:: guesses.map(improve)</span><br><span class="line"><span class="comment">// This is another method, using map</span></span><br></pre></td></tr></table></figure></p>
<h3 id="functions-for-collections">Functions for collections</h3>
<h4 id="mapping">Mapping</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f: <span class="type">T</span>=&gt;<span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] = xs <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; xs</span><br><span class="line">		<span class="keyword">case</span> x::xs =&gt; f(x) :: xs.map(f)</span><br></pre></td></tr></table></figure>
<p>Actual defiintion of map is tail-recursive and works for arbitrary
collections.</p>
<h4 id="filtering">Filtering</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">T</span>] = <span class="keyword">this</span> <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="keyword">this</span></span><br><span class="line">		<span class="keyword">case</span> x::xs =&gt; <span class="keyword">if</span> p(x) <span class="keyword">then</span> x::xs.filter(p) <span class="keyword">else</span> xs.filter(p)</span><br></pre></td></tr></table></figure>
<h3 id="for-expressions">For-Expressions</h3>
<p>For-expression is similar to loops, but it builds a list of the
results of all iterations. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">yield</span> e <span class="comment">// s: generators and filters, e: an element returned by the iteration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> </span><br><span class="line">	i &lt;- <span class="number">1</span> until n</span><br><span class="line">	j &lt;- <span class="number">1</span> until i</span><br><span class="line">	<span class="keyword">if</span> isPrime(i+j)</span><br><span class="line"><span class="keyword">yield</span> (i,j)</span><br><span class="line"><span class="comment">// This expression equals to (1 until n).flatMap(i =&gt; (1 until i).map(j =&gt; (i,j))).filter((i, j) =&gt; isPrime(i+j))</span></span><br></pre></td></tr></table></figure> The type of the sequence can
be modified at the start: <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> </span><br><span class="line">	i &lt;- (<span class="number">1</span> until n).toSet</span><br><span class="line"><span class="keyword">yield</span> </span><br><span class="line">	i</span><br><span class="line"><span class="comment">// thus will generate a set</span></span><br></pre></td></tr></table></figure> For expressions can be used
with pattern matching. <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> </span><br><span class="line">	<span class="keyword">case</span> (<span class="string">&quot;phoneNumbers&quot;</span>, <span class="type">JSON</span>.<span class="type">Seq</span>(numberInfos)) &lt;- bindings(jsData)</span><br><span class="line">	numberInfo &lt;- numberInfos</span><br></pre></td></tr></table></figure> With case, only take certain
elements that match the case pattern.</p>
<p>The syntax of <code>for</code> is closely related to the higher-order
functions <code>map, flatMap, filter</code> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x &lt;- e1 <span class="keyword">yield</span> e2</span><br><span class="line"><span class="comment">// is translated to </span></span><br><span class="line">e1.map(x =&gt; e2)</span><br></pre></td></tr></table></figure> ###
Functional random generators <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Generator</span>[+<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tenerate</span></span>(): <span class="type">T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> integers = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">Int</span>]:</span><br><span class="line">	<span class="keyword">val</span> rand = java.util.<span class="type">Random</span>()</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>() = rand.nextInt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>, <span class="type">S</span>](g: <span class="type">Generator</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(f: <span class="type">T</span> =&gt; <span class="type">S</span>) = <span class="keyword">new</span> <span class="type">Generator</span>[<span class="type">S</span>]:</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>() = f(g.generate())</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> booleans = integers.map(x =&gt; x&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure> #### Random Test Function
ScalaCheck</p>
<h1 id="syntactic-miscellaneous">Syntactic Miscellaneous</h1>
<h2 id="makestring">makeString</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">s&quot;<span class="subst">$&#123;&#125;</span>....<span class="subst">$&#123;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>s</code> means where the string begins, and everything in the
braces following a <code>$</code> will be interpreted as an expression
evaluated.</p>
<h2 id="override-def">override def</h2>
<p>Not to use default methods but our own methods.</p>
<h2 id="conditions">Conditions</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="type">Expr</span>, <span class="string">&quot;IllegalArgumentExceptionMessage&quot;</span>) <span class="comment">// check the precondition</span></span><br><span class="line">assert(<span class="type">Expr</span>, <span class="string">&quot;AssertionErrorMessage&quot;</span>) <span class="comment">//check the bugs</span></span><br></pre></td></tr></table></figure>
<h2 id="infix-notation">Infix Notation</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extention (x: <span class="type">Rational</span>):</span><br><span class="line">	<span class="meta">@infix</span> <span class="function"><span class="keyword">def</span> <span class="title">min</span></span>(y: <span class="type">Rational</span>): <span class="type">Rational</span> = ...</span><br></pre></td></tr></table></figure>
<p><code>r min s</code> = <code>r.min(s)</code></p>
<p><code>r+s</code> = <code>r.+(s)</code> ### Precedence Rules</p>
<h2 id="exceptions">Exceptions</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exc</span>(<span class="string">&quot;Message&quot;</span>) <span class="comment">//type: Nothing</span></span><br></pre></td></tr></table></figure>
<p>A try/catch expression consist of a body and one/more handlers.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">catch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> e: <span class="type">NoSuchElementException</span> =&gt; ... </span><br><span class="line">	<span class="keyword">case</span> <span class="type">BadInput</span>(msg) =&gt; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/precedence.png" /> ## Repeated parameter
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](as: <span class="type">A</span>*): <span class="type">List</span>[<span class="type">A</span>] = ...</span><br></pre></td></tr></table></figure> <code>*_</code> none or several parameters of type A can
be taken.</p>


  </article>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="busuanzi center">
    page PV:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    site PV:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    site UV:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © Azure 2020-2022
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
